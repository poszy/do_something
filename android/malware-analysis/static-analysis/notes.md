# Static Analysis Techniques

## Find entry points 

### check Manifest File for malicious permissions

- first step is to check android permissions in the manifest. some malicious permissions include

BIND_NOTIFICATION_LISTENER_SERVICE
BIND_JOB_SERVICE

##### allows apps to access the notifications shown to the user by all other apps
```xml

<service android:name="com.bp.statis.bloodsugar.PE" 
         android:permission="android.permission.BIND_NOTIFICATION_LISTENER_SERVICE">
  <intent-filter>
    <action android:name="android.service.notification.NotificationListenerService"/>
  </intent-filter>
</service>

``` 

anything that starts with READ_
READ_CONTACTS
READ_SMS
READ_CALL_LOGS

### Exported activities

- android:exported=”true” can be started from outside the current app and so are considered entry points.

- As of android versions 12 and beyond, exported tag must be explicitly stated. before that, there were security vulnerabilities in apps because developers would have their activities exported. since before android 12 exporting was the default

```xml

<activity android:name="com.bp.statis.bloodsugar.MainActivity" 
          android:configChanges="screenSize|orientation">
  <intent-filter>
    <action android:name="android.intent.action.MAIN"/>
    <category android:name="android.intent.category.LAUNCHER"/>
  </intent-filter>
</activity>
```

##### no malicious activity ^^

### Broadcast Recievers

- broadcast receivers can be declared in the manifest. or they can be declared at runtime. at runtime its harder to analyze statically. dynamic analysis is needed to see if the app does something malicious. BR's that are declared at run time can be using reflection . taht is context-registed-recievers. starting with android 26 system uses only manifest declared recievers to wake up apps. context-registerd recievers can operate only when an app is already running.

### Services 

- Developers must declare all services in an app’s manifest file, making them easily discoverable. While services are not entry points into apps (all services must be launched by the running app itself), 

### Subclassing

- subclasses of the android.app.Application class. By default, all Android apps have an implementation of this Java class. 

- See examples/subclassing.java


## Anti-Analysis Techniques

- pretty much anything you can think of to avoid being detected. is being done. stalling code executing. checking which country or carrier. detecting if in an emulator or sandbox

-  app packers, which take an app and encrypt or compress its original code. Many off-the-shelf app packers exist for Android, usually marketed as tools to protect intellectual property. 

- Some try to detect analysis tools, such as emulators, debuggers, or sandboxes, and avoid running if those tools are detected


## Reflection 

- this is a standard api, java.lang.reflect. is used to dynamically look up, instantiate, and invoke classes and methods 

- reflection is used to make code difficult to read and used to call or instantiate objects inline. mostly in one liners

- they can hide malicious code using reflection to avoid static or dynamic analysis but the use of reflection cannot be hidden. a dead giveaway that something is possibly being done maliciously.

- see exmaples/reflection.java


## Non Java Code

- some apps are written with frameworks like flutter and other languages like kotltlin.

- some apps juse javascript or native arm code, which is compiled with c++/c. try to find such code in apps. its usually a telling sign that its being used to obfuscate other malicious code. 

- native code is found in the lib/ folder

- Java code keywords for interacting with native code such as native or the API System.loadLibrary

-  Look for JavaScript in WebView objects, in particular those declaring a JavaScript interface through the API addJavascriptInterface.


## Encryption and Encoding 

- malware writters use default java implementations of encrcryption algorithms. such as AES or RSA

- found in javax.crypto package, java.util.Base64, android.util.Base64. 

- look at strings and method names used in apps, to spot interesting. This technique takes only a couple of minutes and can lead to new discoveries. For example, malware developers may have forgotten to remove sensitive log strings, or the search might reveal an API call to read the user’s SMS messages. Though this can waste a lot of time. 

- Opaque predicates are expressions that evaluate to true or false and look complicated to calculate, yet always resolve to the same value.

- Malware uses them to confuse human and automated analysis, for instance by making it harder to follow how if statements branch or how often loop statements repeat.

- it’s easy to eyeball whether the check is for a legitimate API version or a realistic calendar date. The arithmetic expressions and assignments of seemingly random values to attributes all look similar, too. As a human reviewer, you can make use of your brain’s pattern-recognition powers and rapidly scan the code to find instructions that are visually different

- The crucial mistake that allowed us to speedily recover the decryption code is that the developers mixed original instructions with obfuscating instructions but kept the data flow of the original code completely separate from the data flow of the obfuscated code. Thus, the code initially appears difficult to read and hard to follow, but when we look only at variables and how they influence each other, we can easily extract the original code without having to consider the obfuscation at all.

## Entry Points
- ban.java dynamically loads plug in files. the analysis will differ from first-stage analysis, that is looking at manifest and permissions. plug in files do not have a manifest file, making it much harder to find permissions or entry points. they have no predefined entry points. 

## Permissions
- ban.java can only use permissions declared in the manifest file of the app that loads them. knowing this we cna see which permissions were discovered previously

- searching text for the permissions show two parts inside of ban.java. read_contacts , read_phone_state. 
